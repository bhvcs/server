배경:
기존에 사용하던 GitLab은 다른 회사와 공유하고 있었다. 회사가 이전하면서 서버를 분리해야 했고, 이를 위해 사냐 별도의 GitLab을 구축하기로 했다.

먼저 남는 컴퓨터에 우분투를 설치했다.
( 우분투를 사용하는 이유 )
  1. 리눅스는 무료 오픈소스 운영체제. 365일 돌아가야 하는 서버가 무료라는 것은 큰 이점.
  2. 오픈소스 운영체제라 오히려 보안성이 좋음.
  3. 오픈소스라 버그나 위협을 많이 해결왔음 -> 안정성

파티션 설정
사수께서 우분투를 설치할 때 파티션 설정을 했다고 들었다. 파티션 설정은 왜 필요한가?
데이터를 저장할 때 디스크를 사용한다. 이때 하나의 디스크를 논리적으로 분리해서 운영체제에게 독립적인 디스크로 인식되게끔 하는 것.
우분투를 설치할 때 파티션 설정이 고려 요소인 이유는 우분투 설치할 때 버전이 있는 것을 볼 수 있는데, 이 때, 운영체제를 버전업하려고 프로그램을 다 밀어버리기 보단, home 디렉토리를
os가 들어있는 root와 분리시켜 root만 밀고 다시 설치하면, 자연스러운 버전업이 된다.

지금까지 우분투를 설치할 때, 파티셔닝을 직접해본적이 없는데, 우분투 자체에서 default로 해준 파티셔닝을 사용한 것이다. (default로 dev/sda 라는 공간을 볼 수 있다. device/scsi(small computer system interface)의
약자이다. 그냥 sd는 데이터를 담는 모든 장치이고 그 뒤에 a, b, c로 디스크를 구분한다.)

SWAP
파티션 설정 중에 맨 처음 할 일은 SWAP 파티셔닝이다. 
swap 영역은 학부 운영체제 수업 때도 배웠지만, 우리가 사용하는 메모리의 공간이 부족해졌을 때 하드디스크의 일부 공간을 메모리처럼 사용하기 위해
따로 할당하는 영역이다. 이 영역은 보통 메모리 용량의 배수로 설정한다고 한다.(두배?) swap 영역은 하드디스크에 -> 속도가 느림. 서버의 성능을 생각해서 맨 앞단에 놓아야 한다. 하여 파티션 타입을 Primary로.
파티션의 위치를 맨 앞단으로. 

Root
루트 파일 시스템을 위한 파티셔닝이다. 보통 부트 파일, 로그 파일, 커널 등이 이곳에 저장된다. BIOS는 부트 로더를 primary 파티션에서만 찾는다. 하여 부트 파일이 있는 Root 파티션은 무조건 primary 파티션으로
지정해야 한다.
** GPT 디스크에는 primary 파티션 밖에 없다고 한다. (my: 2.2 이상의 하드디스크를 인식할 수 있는, 4개 이상의 주 파티션을 지원하는 것을 GPT라고 들었던 것 같다)

**
UEFI(Unified Extensible Firmware Interface) 와 BIOS(Basic Input-Output System)
둘 다 운영체제가 시작되기 전, 컴퓨터를 부팅할 때 돌아가는 프로그램이고, 운영체제를 깨우는 방식에 있어서 차이가 있다.
UEFI가 후속 모델이다 -> 신식.
보안 측면에서 더 유리하고, 2.2TB 보다 큰 용량의 하드드라이브까지도 인식할 수 있다. EFI 실행 파일을 동작시킬 때 GPT(MBR x) 를 사용한다.

우분투 위에 도커 설치.
도커에 대해서 알아보기 전에 분산 애플리케이션을 먼저 알아봤다.
하나의 컴퓨터에서 애플리케이션을 실행시키는 상황을 생각해보자. 그 컴퓨터에서 장애가 발생하면 실행 중이던 애플리케이션도 사용할 수 없게 된다. 이 때, 애플리케이션을 분산시켜 여러 컴퓨터에서
작동시키면 일부 컴퓨터에서 장애가 발생하더라도 계속 서비스를 제공할 수 있는 것이다. 하여 규모가 커지는 서비스에 대해 수평적인 확장을 용이하게 해준다. 애플리케이션을 분산 시켰을 때, 명확히 나뉘는
경계로 인해 개발자들이 독립적인 코드 베이스에 작업을 할 수 있다. 이처럼 규모가 큰 애플리케이션일 경우 분산시키는 방법을 생각해야겠다.
이런 분산된 애플리케이션은 일반적으로 docker를 사용해, 컨테이너 단위로 나뉘어 실행된다.

컨테이너를 사용하는 이유는 내 개인 인프라와 애플리케이션이 돌아가는 공간의 인프라를 분리시켜서 운영 환경을 효율적으로 관리할 수 있는 것이다.
게다가 가벼워서 한 호스트 내에서 여러 사본을 실행 가능. 거기에 컨테이너는 여러 네트워크와 연결될 수 있고, 저장소 또한 붙일 수 있다.


물론 VM 위에 분산 시키는 것도 가능하지만 컨테이너 위에서 돌리는게 훨씬 효율적이다.
1. VM은 전체 OS 인스턴스 및 하이퍼바이저의 페이로드(?)를 전달하지만, 컨테이너는 코드를 실행하는 데 필요한 OS 프로세스와 종속성만 포함하면 되어서, 훨씬 가볍다.
VM보다 훨씬 많은 애플리케이션의 사본을 실행시킬 수 있다.
2. 애플리케이션을 컨테이너에 만들어놓으면 어디서나 실행 가능하고, VM보다 훨씬 빨리 배포, 프로비저닝, 재시작을 할 수 있어서 개발자의 생산성을 향상시킨다.

위에서 예기했다시피 컨테이너는 이처럼 유용하다. 컨테이너 기술은 우분투에도 당연히 포함되어 있다. 하지만 네이티브로 컨테이너화 하는 것은 당연히 어려울 것이다.
그래서 등장한 것이 도커. 컨테이너화가 아주 편리하게 된다. 다른 장점들도 있지만, 지금으로써는 이게 가장 큰 장점으로 다가온다.

도커를 사용하면 컨테이너마다 인프라를 설정해줄 수 있다는 것, 즉 내 애플리케이션을 관리하는 것처럼 컨테이너의 인프라를 구성하면 된다.
도커를 사용하면 개발 사이클에 큰 편리를 가져다준다. 버그를 발견하면 개발 환경에서 고치고 -> 테스트 환경에 배포해서 확인 -> 운영 환경에 배포
이정도로 사용해본 적은 없지만, 각 환경에 맞게 컨테이너를 만들어놓고, 그곳에 배포만 하면 빠르게 확인할 수 있는 듯 하다.
** 지금까지 본 회사코드는 환경변수를 배포 환경에 따라 구분시켜놓고, 그 환경에 맞는 환경 변수 값을 사용하는 것으로 보인다. 위에 이야기한 도커의 프로세스를 사용하지 않는 것으로 보인다.
서비스의 규모가 크지 않아서 굳이 사용하지 않는 것인가? 사내에서도 도커를 이런식으로 활용하고 있는지 물어봐야겠다.

도커 프로세스
우리가 도커 명령어를 쓰는 것은 도커 client한테 명령을 내리는 것이다. 그러면 도커 client는 이를 docker api로 Docker Daemon과 소통한다. 
도커는 컨테이너를 만들 때, 마지막 레이어에 file system을 할당해준다.
개별적으로 네트워크를 설정하지 않았다면, 도커는 컨테이너에 디폴트 네트워크를 연결해준다. 이떄, 컨테이너에 IP address를 할당해준다.
기본적으로, 컨테이너는 host 머신에 연결된 네트워크를 통해 외부 네트워크와 연결된다. ( container -> host machine -> external network )

image
image는 컨테이너를 만드는 데 필요한 멸령어가 있는 템플릿임. 이미지를 만들기 위해선 Dockerfile이 필요하다. Dockerfile 내의 명령어들이 이미지의 각 레이어를 생성한다.
컨테이너는 image의 runnable한 인스턴스임.
사내 깃랩을 구축하는 것이 목표이기 때문에 gitlab 이미지를 다운 받았다. docker hub에서 다운받는다.

**도커는 근데 왜 쓴거야?
우분투 깔았으면 그냥 거기에 깃랩 깔면 되는거 아닌가? 사내 서버이다. 깃랩만 돌리는 서버가 아니겠지. 도커는 컨테이너간 namespace 기술을 이요한
분리가 잘되기 때문에 도커를 사용하지 않았을까.

